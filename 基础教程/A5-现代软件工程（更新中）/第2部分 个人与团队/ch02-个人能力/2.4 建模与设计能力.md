## 2.4 建模与设计能力

<center>
<img src="Images/Slide6.JPG"/>

图 2.4.1 建模
</center> 

### 2.4.1 建模题

建模题一般就是考察面试者对事物的观察归纳能力以及面向对象的设计思想，这种设计仅限于对象级别的，稍微复杂一些的会涉及到组件级别，而非系统级别的。

#### 给一个会议室建模

- 定义会议室

```Python
class MeetingRoom():
    location: Geometry  # 位置
    no_room: str        # 会议室编号
    no_seat: int        # 座位数
    has_projetor: bool  # 有无投影仪
    has_whiteboard:bool # 有无白板
    has_network: bool   # 有无网络会议设备
```

- 定义会议

```python
class Meeting():
    start: time         # 开始时间
    end: time           # 结束时间
    host: People        # 主持人
    topic: str          # 议题或内容
    owner: People       # 订会议室的人
    status: Normal      # 状态(正常、进行中、取消、已结束)
```

给出了会议室的定义后，如果能够一鼓作气给出会议的定义，会更好，说明你思路清晰。因为有的面试者会误把会议的内容定义到会议室里面去。

#### 给一个十字路口的红绿灯系统建模

- 定义基本枚举值

```python
class Colors():
    Red = 1         # 红灯
    Green = 3       # 绿灯

class Status():
    On = 1          # 亮起
    Off = 0         # 熄灭
```

- 定义单个灯

```python
class Light():
    # 属性
    status: Status 
    # 动作
    def TurnOn(color)   # 开灯并指定颜色
    def TurnOff()       # 关灯
```

上面的定义中，开灯或关灯与具体的交通信号含义无关，还需要上层对象来调用。

- 定义灯组，至少两个灯组成一个灯组

```Python
class LightGroup():
    # 属性
    light_Straight: Light   # 直行灯
    light_LeftTurn: Light   # 左转灯
    # 动作
    def SetStraight(On|Off) # 允许|禁止直行
    def SetLeftTurn(On|Off) # 允许|禁止左转
```

上面的动作定义中，就可以对应得到具体的交通信号含义了。

- 定义中控器

```python
class ControlCenter():
    light_groups: LightGroup[4] # 路口的每个方向都有一个灯组
    scheduler: timer   # 定时器，用于对LightGroup进行定时开关操作
```

最后，每个十字路口都肯定会有一个中控器来控制四组灯的信号以保证其协调性。这一点往往是面试者容易忘记的，原因是他们并没有观察到有时候警察叔叔会手动操作中控器来控制交通流量。

#### 给一个魔方建模

很多没有玩过魔方的人，会对此问题一筹莫展。在实际的面试时，可以要求面试官提供一个魔方，供面试者动手观察。

一个魔方的单面有：

- 一个中心块
- 四个棱块
- 四个角块

而扩展到六面以后，总共会有：

- 六个中心块
- 八个角块
- 十二个棱块

如果仔细观察的话，魔方的中心块实际上只能原地旋转，六个中心块的相对位置是不会发生变化的，而所谓的还原魔方，就是把与中心块相同的颜色都拼在一起。所以可以用中心块的颜色来代表六个面。

先定义块的颜色和位置：

```python
# 颜色
class Colors(Enum):
    White = 0
    Red = 1
    Yellow = 2
    Blue = 3
    Green = 4
    Orange = 5

# 位置, 以魔方的中心点为坐标(0,0,0), 每个块在[-2,+2]之间
class Position():
    x:int
    y:int
    z:int
```

再从最小的单元块定义：

```python
# 块的基类
class Block():
    postion: Position

# 中心块, 一种颜色
class CenterBlock(Block):
    color_0: Colors

# 棱块, 两种颜色
class EdgeBlock(Block):
    color_0: Colors
    color_1: Colors

# 角块, 三种颜色
class CornerBlock(Block):
    color_0: Colors
    color_1: Colors
    color_2: Colors
```

然后定义一个面：

```python
# 一个面
class Side():
    # 属性
    center_block: CenterBlock      # 1个中心块
    corner_blocks: CornerBlock[4]  # 4个角块
    edge_blocks: EdgeBlock[4]      # 4个棱块
    # 动作
    def Rotate_90():  pass
    def Rotate_180(): pass
    def Rotate_270(): pass
```

最后定义整个魔方：

```python
# 一个魔方
class RibukCube():
    side_Front: Side
    side_Back:  Side
    side_Up:    Side
    side_Down:  Side
    side_Left:  Side
    side_Right: Side
```

给魔方建模有几个误区：

- 从静态结构上把它分成上、中、下三层
- 从动作上多定义一个中心层的旋转
- 用颜色代替块的概念（颜色只是块的一个属性而已）
    
如果有中心层，并且可以旋转的话，整个模型会变得非常复杂而不可描述，实际上中心层的“正向”旋转可以用两个边层的逆向旋转来表达，但是所谓的“正向”是无法定义清楚的，不像每个面那样可以把旋转 90 度和旋转 270 度区分开。

### 2.4.2 设计

应用场景：

- 甲方每天早晨 8:00 传给乙方前一个交易日的股票大盘数据
- 乙方收到数据后，立刻验证数据是否齐备，然后使用已有模型做股票价格预测
- 需要在 9:30 之前把预测结果发送回甲方

限制条件：

- 保存所有的历史大盘及预测记录
- 全自动化，无人干预
- 用微软 Azure 提供的技术

这个问题需要有一定的系统设计能力了

<center>
<img src="Images/Slide7.JPG"/>

图 2.4.2 股票预测系统设计
</center> 

