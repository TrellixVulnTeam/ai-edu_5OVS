## 2.3 算法与编码能力

在木头的面试中，有过这样一道题，如图 2.3.1 所示。

<center>
<img src="Images/Slide4.JPG"/>

图 2.3.1 算法与代码能力
</center> 

有一个 [0-100] 的数组，在随机位置无回放地从 1-100 共 100 之间取一个数填入，还富余出一个空位，随机填入 1-100 之间的任意一个数。求重复的数字是什么？至少用 5 种方法写出代码求解。

下面我们列出从简单到复杂的几种解法，其实这个问题本身就不难，所以解法也很容易理解，仅供读者开阔思路。

```python
import random

max_number = 10     # 以最大值为10为例，便于说明问题，读者可以自行改到100

def generate_data():
    data = [i for i in range(1, max_number+1)]  # 生成一个顺序数组
    data.append(random.randint(1, max_number))  # 最后随机填一个数
    print("顺序数组=",data)
    random.shuffle(data)                        # 打乱顺序
    print("乱序数组=", data)
    return data
```
生成的数组：

```
顺序数组= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 4]
乱序数组= [5, 10, 8, 4, 3, 2, 7, 1, 4, 6, 9]
```

以下各算法将针对乱序数组求解。

### 求和法

小学生都知道：

$$
\sum_{i=1}^{100}=\frac{1+100}{2} \times 100=5050
$$

所以把 101 个数组单元内的数字相加，在减去 5050，得到的数字就是重复的数字。比如求和结果是 5061，则 $5061-5050=11$，11 就是重复的数字。

算法时间复杂度：$O(n)$，因为所有数字遍历一遍。
算法空间复杂度：$O(1)$，只需要保留求和结果。

```python
def method_1_sum(data):
    sum = 0
    for x in data:
        sum += x
    #print(sum - 5050)
    print(sum - int((1+max_number)*max_number/2))
```

### 哈希法

使用一个哈希表来顺序保存 101 个单元内的数字，那么在哈希表中重复的那个数字就很容易得到。

比如在 Python 中，字典就是有哈希表功能的。

算法时间复杂度：$O(n)$，最坏情况下所有的数字遍历一遍存放到字典中。
算法空间复杂度：$O(n)$，需要一个额外的字典来保存数据。

```python
def method_2_dict(data):
    dict = {}
    for x in data:
        if dict.__contains__(x):    # 字典中已经有此数，是重复的
            print(x)
            return
        else:                       # 如果字典中没有此数，则保存
            dict[x]=1   
```

注意，这里不能使用数组的 “__ contains __” 函数来判断是否已经存在相同的值，因为该函数是遍历方式搜索，属于 $O(n^2)$ 的时间复杂度。


### 排序法

首先对原数组进行排序，然后从头遍历找到重复的数字。

算法时间复杂度：$O(n\log n)$，因为数组的 sort() 函数使用了快速排序的算法。
算法空间复杂度：$O(1)$，排序时需要的缓冲。

```python
def method_3_sort(data):
    data.sort()  
    for i in range(max_number+1):
        if data[i] == data[i+1]:    # 相邻的两个数相等，是重复数字
            print(i+1)
            return
```


### 搜索法

如图 2.3.1 所示，我们以 5 个数字为例来简化说明问题。

1. 从位置 0 取出数字 3，放到位置 3；
2. 从位置 3 取出数字 2，放到位置 2；
3. 从位置 2 取出数字 1，放到位置 1；
4. 从位置 1 取出数字 5，放到位置 5；
5. 从位置 1 取出数字 1，放到位置 1，但发现位置 1 上已经是 1 了，是重复数字。

算法时间复杂度：$O(n)$，这是最坏的情况，大多数时候可以提前结束。
算法空间复杂度：$O(1)$，交换数字时的缓冲。

```python
def method_4_search(data):
    pos = 0                 # 从 0 位开始
    x = data[pos]           # 从 0 位取出数字
    while (True):
        if (x == pos):      # 在目标位置上已经有一个相同的数字，是重复的
            data[0] = x     # 不是必须，只是把重复的数字放到第 0 个位置上
            print(x)
            break
        pos = x             # 保存 x 的值到 pos，即
        x = data[pos]       # 取出 pos 位置的数值 x
        data[pos] = pos     # 把 pos 位置成 pos 值，如，第 3 个数组单元就置成 3

    print(data)
```

### 异或法

异或运算满足交换律和结合律，并且 $x \oplus x = 0, x \oplus 0 = x$。

假设重复的数字为 $x$，则包含有两个 $x$ 的乱序数据的异或结果为：

$$
T_x = 1 \oplus 2 \oplus 3 \oplus \cdots \oplus x \oplus x \oplus \cdots \oplus 100 
$$

没有重复的数字的连续的 100 个整数的异或结果为：

$$
T_n = 1 \oplus 2 \oplus 3 \oplus \cdots \oplus x \oplus \cdots \oplus 100
$$

二者异或：

$$
\begin{aligned}
T_x \oplus T_n &= (1 \oplus 1) \oplus (2 \oplus 2) \oplus \cdots (x \oplus x \oplus x) \oplus \cdots \oplus(100 \oplus 100)
\\
&= 0 \oplus 0 \oplus \cdots \oplus (x \oplus x \oplus x) \oplus \cdots \oplus 0
\\
&= 0 \oplus x
\\
&= x
\end{aligned}
$$

即二者异或结果就是重复的数字 $x$。

算法时间复杂度：$O(2n)$，两遍异或运算。
算法空间复杂度：$O(2)$，保存异或结果。

```python
def method_5_xor(data):
    # 求所有数字的异或结果，包含重复的数字
    tmp_x = 0
    for i in range(len(data)):
        tmp_x = tmp_x ^ data[i]
    print(tmp_x)
    # 求 1~max_number 的异或结果
    tmp_n = 0
    for i in range(max_number):
        tmp_n = tmp_n ^ (i+1)   # 注意是 i+1，不是 i，因为 i 从 0 开始
    print(tmp_n)
    # 上面两者异或，可以得到重复的数字
    print(tmp_x ^ tmp_n)
```
